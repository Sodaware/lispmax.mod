#+TITLE: LispMax - A LISP for Blitz

https://github.com/kuzux/lispcan/tree/master
https://github.com/robert-strandh/SICL/tree/master/Code/Environment
http://recurial.com/programming/interpreting-scheme-syntax-part-1/
http://homepage1.nifty.com/bmonkey/lisp/sacla/index-en.html
https://github.com/fogus/lithp/tree/master/src

* Tasks [15/27]
** TODO Add "cond"/"else"
** DONE Add "when"
** DONE Add logic helpers [3/3]
   - [X] or
   - [X] and
   - [X] not
** DONE [#A] Re-implement progn
** TODO [#A] Fix "LET"
   Doesn't seem to work correctly, so we can't build "cond" out of it
** TODO [#A] Fix mapcar
   Looks like there's a problem in how passing a quoted function pointer or
   something. Not being found in the function table?
** TODO [#C] Add garbage collection
** DONE Implement &rest
   https://github.com/vsedach/Parenscript/blob/master/src/parse-lambda-list.lisp#L77
** TODO Implement &optional
** DONE Implement &key (named parameters)
** DONE Allow &key to have default values
** TODO Implement funcall
   This can probably be done in lisp once quote/unquote are working
** TODO Implement "labels"?
** TODO Add exceptions to Lexer
   - [ ] Unterminated string
   - [ ] Unterminated symbol
   - [ ] Unterminated number
** TODO Optimizations [2/6]
*** DONE Replace current environment system with a dedicated type
    - The current system is slow when setting variables - to set 1000 variables
      takes around 58 millisecs, wheras it only takes 9 seconds for a
      TMap. Retrieving values is about 100 times faster with a TMap
*** TODO Possibly replace symbol table TMap 
    - Possibly ObjectHash like in the BlitzPlus days. Not sure if C++ would be
      significantly faster
*** TODO Remove use of Global (apparently slow)
*** DONE Replace Chr()/string comparison code with straight ASCII lookups
    - Worked!
*** TODO Implement a pool for atom objects?
*** TODO [#A] Pull =when= out of site-lisp and into core
    The =when= macro is slow (because quasiquoting is slow), so it is probably
    better to have it as part of the core.
    As it currently stands, =when= takes about 100 times longer to execute, and
    has taken as long as half a second. Not good.
** TODO [#C] Add "defun" macro
   - (defun function-name (params) docstring body) ;; body is implicit progn
** TODO Rewrite lispmax_core.bmx and merge unused stuff
   Now that it runs as a stack-based app (and not much slowed), we can remove
   some of the builtin stuff and cleanup the main Lisp process
** TODO Counts "tab" as a symbol -- fix this!
** DONE Add "progn"
** DONE Fix bug with macro expansion
   - Currently macros work the first time they are called, but not the
     second. 99% sure it's due to Blitz treating everything as a reference, so
     not sure how to fix it...
     - In the end added a shallow copy option. It's absolutely not perfect, and
       I'm not convinced it'll work for anything advanced, but it works for now.
** DONE Add "setq"
** DONE Convert to BlitzMax module
** DONE [#A] Add unquoting
** DONE Figure out why comments aren't being ignored
   Couple of bugs here - the comment checked wasn't searching for the right
   character, and readAll was not adding newlines so comments were never
   terminated
** DONE Add more FFI capabilities
   - Add support for class methods (using a custom type)
** DONE Add support for symbols prefixed with ":"
   CLOCK: [2014-08-19 Tue 18:50]--[2014-08-19 Tue 19:00] =>  0:10
   CLOCK: [2014-08-19 Tue 18:03]--[2014-08-19 Tue 18:13] =>  0:10
   http://www.arclanguage.org/item?id=12197
   - If a symbol starts with ":", it should be treated as a symbol with the
     same value
   - So evaluating :symbol will return a symbol with value :SYMBOL
** DONE Add continuations
* Version History

** Version 0.1

  - Implemented atoms and pairs. Can't use a union, so have to store all data
    types in the base Atom. Not ideal, but sub-classing is too complex for an
    early version, and I'm not convinced it would make life easier.
  
  - Added cons, car and cdr

  - Implemented printing atoms. Can handle all of the basic types. Hurray!

  - Added a very simple symbol table using BlitzMax's built in Map. The symbol
    table is used to make sure there is only once instance of a symbol at a
    time (like it should be)

  - Currently no error checking on car/cdr. Also some sloppy creation for Pair
    values.


** Version 0.2

  - Lexing. Lexer currently reads one token at a time when called. Tokens are
    returned as a Token object that contains the type, location and contents of
    the token. Currently does not store the previous tokens or allow "peeking"
    to find the next one.
    
  - Parsing -- The version in the tutorial passes a lot of stuff by reference
    and makes use of C's macro functionality. This isn't something we can use,
    so need to be a little more thoughtful when laying things out.

  - Replaced the previous iteration of car/cdr. If a value is passed in, the
    car/cdr will be set. Otherwise the value will be returned.

  - Current version can parse a basic list, nested list or improper list (key /
    value pair). Doesn't work with strings yet.


** Version 0.3

  - Expressions, environments and evaluation
    
  - Environments are currently standard lisp structures. It might be better to
    use a specialised type, but I'm not sure if that would make it difficult to
    take advantage of more "lispy" stuff

  - Fixed a couple of bugs in the lexer, so it now reads strings properly and
    can read a whole number rather than just a single digit

  - Fixed the intepretor to add a null byte to strings. This expressions that
    aren't surrounded by parenthesis work (i.e. for querying a symbol's value).

  - Environments now work correctly. Not convinced they'll be quick enough for
    large-scale scripting, but for now they should be fine

  - Can now evaluate very simple expressions, define variables and get their
    values

** Version 0.4

  - Added ability to call builtin functions, such as car, cdr and cons. This
    needed a new atom type. Builtins can be added to the environment, and are
    just BlitzMax function pointers. Works surprisingly well.

  - Spent some time cleaning up code and adding proper exceptions and exception
    handling to the REPL

** Version 0.5

  - Added builtin functions for arithmetic (+, -, * and /)

** Version 0.6

  - Closures! These were surprisingly easy to add. The code is a little ugly,
    but the underlying method is quite elegant.

** Version 0.7

  - New special form: IF
  
  - New global symbol "T"

  - New builtin functions: "=", "<" and ">"

  - Starting to hit a couple of problems with builtin functions using function
    pointers. BlitzMax doesn't allow methods to be used as function pointers,
    but some builtin functions need access to the internals when returning
    symbols. Might have to wrap methods, or come up with something else entirely.


** Version 0.8

  - Time to make things prettier. Added ' symbol, that works the same as "quote"

  - Updated "define" to also define functions. Happy times.

** Version 0.9

  - Variadic functions! Again, not much really needed to change here, just a
    slightly different way of binding variables

  - Cleaned up code again as it's getting a little scruffy

** Version 0.10

  - Added support for macros:
    
    - Added an extra atom type (macro)

    - Updated evaluation to take macros into account

** Version 0.11

  - Added support for loading library functions from a stream. This can be any
    BlitzMax stream, which means they can loaded from zips/network etc
    
  - Fixed lexing issue when reading negative numbers. If the lexer hit a "-",
    it would assume it was a symbol. Added "peekChar", which allows the lexer
    to look ahead/behind for characters without changing the internal pointer.

** Version 0.12

  - Cleaned up a lot more code, and started process of splitting everything up
    so it can be used as part of a module

  - Added special form: "progn". progn evaluates all passed in forms (in the
    order they are passed in) and returns the result of the last form

  - Added special form: "setq". Used for setting multiple variables at once.

** Version 0.13

  - Performance enhancements:

    - Replaced environment atom with custom LispMax_Environment type.

    - Changed lexer to use byte comparison instead of string comparison

    - Removed references to Chr$() with a string lookup. About 5% faster this
      way.

  - 

* Notes

  - Lexer returns a Token class instead of just a straight integer. Not the
    most memory efficient way of doing things (might get rid of it), but should
    give us the information needed.
    
    https://github.com/doctrine/lexer/blob/master/lib/Doctrine/Common/Lexer/AbstractLexer.php
    is a good place to look

  - Lexer needs:
    
    - input string

    - tokens - list of scanned tokens (so far)

    - position

  - Replacing chr(char) checks with pure ascii checks increased lexer speed by
    about 20%

  - Adding a lookup (instead of chr()) and changing isSymbolChar to use a
    constants and a giant select has cut the overall lex time to about 30% of
    its original

    (was 4440 ms to parse), is now 1362

  - Replaced environment with a custom data type. Loses some power from the
    previous version as the environment can't be output like a regular lisp
    atom. But it's about twice as fast.

  - Continuations

    - Need to replace the main evaluation part with a loop and some helpers for
      managing the stack.

    - Stack is a collection of stack frames. Each frame links to the parent, so
      we don't need to worry about a list or anything.
      
    - Stack frame contains:

      - Parent frame - i.e. the frame that wants the result of this frame

      - Environment - current env

      - Evaluated operator

      - Pending arguments

      - Evaluated args

      - Body - expressions in function body that are pending execution

    - Stack-based approach is (mostly) working now. Fixed the biggest issue
      which was caused by blindly copying code instead of reading it - the
      closers in LispMax are (cons args body), whereas the tutorial I'm using
      contains the environment as the car and the body as cddr.

    - let still needs fixing, but nearly everything else is good. Just need to
      strip off all of the debug code and optimize it now. (DONE)

    - Split the process-based stuff into a separate type (LispMax_Process) and
      added the ability to run one expression at a time. Also added "suspend"
      command, so it is possible to stop the process from within the
      script.
      
